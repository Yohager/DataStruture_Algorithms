### 排序算法总结

[TOC]

----

#### 1.冒泡排序

冒泡排序是一种交换排序：两两比较排序的关键词，交换不满足要求的那对数。

数组中的相邻的两个数进行比较，数组中较小的数值向下沉，数值较大的向上浮，外层循环控制循环的次数，内层循环控制的是相邻元素的两个元素的比较。

（算法比较简单，不多赘述，以后有空补充添加标志位的改进版本）

代码见：`bubble_sort.c`

算法时间复杂度：$O(n^2)$

#### 2.选择排序

选择排序的算法流程大概是这样的：首先找出数组中最小的元素，其次将它和数组中的第一个元素交换位置，再次在剩余的元素中找出最小的元素，将其与数组中的第二个元素进行交换，如此往复将整个数组排序。

**对于长度为$N$的数组，选择排序需要大约$N^2/2$次比较和$N$次交换。**

选择排序的两个鲜明特点：

1. 运行时间和输入无关。（每一次扫描都是独立的）
2. 数据移动是最少的。（每一次交换都会改变两个数组元素的值）

代码见：`selection_sort.c`

算法时间复杂度：$O(N^2)$.

#### 3.插入排序

插入排序顾名思义是指每一次将数组中的一个值插入到已经有序的数组中去。与选择排序类似的，当前索引的左边的所有元素都是有序的，但是它们的最终位置还是不确定的。和选择排序不同的是插入排序所需要的时间与输入中的元素的初始顺序有关。

代码见：`insert_sort.c`

算法时间复杂度：$O(N^2)$.

#### 4.折半插入排序

折半插入排序是插入排序算法的一种改进版本，在获取到第i个无序元素时，在前(i-1)个有序的数组中通过**折半搜索**的方法寻找这个新的无序元素i的插入位置并将这个元素插入到有序数组中形成新的有序数组。

代码见：`binary_insert_sort.c`

算法时间复杂度：$O(N^2)$.

#### 5.希尔排序

希尔排序也称为“缩小增量排序”，是插入排序的一种改进版本，交换不相邻的元素以对数组的局部进行排序。希尔排序的思想是使数组中任意间隔为$h$的元素都是有序。这样的数组被称为$h$有序数组。换句话说一个$h$有序数组就是$h$个相互独立的有序数组编织在一起的组成一个数组。

算法的大致流程：

首先取一个整数increment(小于n)作为间隔将数据分为若干个子序列，在每个子序列中分别执行直接插入排序，然后缩小间隔重复上述的划分和排序直到最后一个间隔取1，将所有的元素放在同一个子序列中进行比较。

由于一开始取的间隔比较大，子序列中的元素较少，排序速度较快；当间隔变小时，子序列中元素的个数逐渐增多，而同时由于前面的工作的基础，大多数元素已经基本有序，因此排序的速度仍然很快。

代码见：`shell_sort.c`

算法时间复杂度：$O(N\log N)$.

#### 6.归并排序

归并排序是一种典型的基于分治思想的递归算法，它不断的将原数组分为大小相等的两个子数组，最终等到划分的子数组的大小为1的时候将划分的子数组合并为一个更大的有序数组。

函数的传递参数：1.原数组，2.临时数组用于存储并的数组元素，3.起始位置，4.结束位置

函数原型可以写为：`void merge_sort(int numbers[], int temp[], int start, int end);`

分治法：

1. *分解*：将一个问题分解为多个子问题，这些子问题是更小的实例上的原问题。
2. *解决*：递归的求解子问题，当子问题足够小的时候按照基础的情况来求解。
3. *合并*：将所有的子问题合并为原问题的解。

对于归并排序我们可以得到这样一个递归表达式：

$$T(n) = 2T(n/2)+\Theta(n)$$

通过“主方法”的标准化方法可以对递推关系式就求解出来：$T(n) = \Theta(n\log n)$

代码见：`merge_sort.c`

算法时间复杂度：$O(N\log N)$.

#### 7.快速排序

像归并排序一样，快速排序也采用的是分治法的思想，然而快速排序与归并排序的思想有一些区别，主要有两个不同点：

1. 快速排序按照原址工作
2. 快速排序的渐近运行时间介于最坏情况和平均情况之间，最坏是$O(N^2)$，平均情况是$O(N\log N)$.

快速排序的算法流程如下：

首先对于一个需要进行排序的数组而言，我们首先将数组的首元素作为**基准值**（这种做法通过在随机的需要进行排序的数组中比较好），基于这个基准值，我们考虑将比这个基准值大的都放在它的右边，同样的道理将比这个基准值小的数都放在这个基准值的左边，进行一次这样的操作之后我们递归进行，每一次都将一个子数组这样操作，最终可以得到排好序的数组。

具体的在算法的code实现上，我们考虑这样进行：函数传递的参数为：原数组，起始位置，终止位置（为了后续的递归调用）。对于这个函数的编写，首先初始化两个指针分别指向子序列的头和尾，同时初始化基准值为这个子序列的首元素，然后考虑从尾部向头部寻找小于基准值的数，找到后将这个数放到头部；如果是大于基准值则继续寻找；在经过一次从尾部的寻找后，从头部也开始寻找比基准值大的数，如果数比基准值大，则将这个数放到尾部去，否则继续下移指针寻找，循环终止的条件是当尾部的指针越过头部的指针。递归进行这样的操作，最终就可以得到我们需要的排好序的数组。

代码见：`quick_sort.c`

算法时间复杂度：$O(N\log N)$.

#### 8.堆排序

堆排序利用了一种名为堆的数据结构，这对存储在数组中的完全二叉树进行排序是一种非常有用的方法。（堆排序属于选择排序的一种）

**堆**：堆表示的是一棵所有的节点的值都大于或者等于其子节点的完全二叉树

1. 堆排序将数据看做完全二叉树，根据完全二叉树的性质来进行排序
2. 最大堆的要求节点的元素都要不小于它的孩子，最小堆要求节点元素都不大于其孩子
3. 处于最大堆的根节点一定是这个堆中最大的元素

完全二叉树的特点：左子节点的位置 = 父节点的位置 *2+1，右子节点的位置 = 父节点位置 *2+2

堆排序的主要算法流程如下：

1. 将需要进行排序的数组构建为堆；
2. 交换堆顶元素和尾部元素；
3. 去掉尾部元素，并重新维护好这个堆，反复执行第二步；

代码见：`heap_sort.c`

算法时间复杂度：$O(N\log N)$.

#### 9.计数排序

计数排序是一种非比较的排序算法，元素从未排序的状态变为已排序的状态的过程是由额外空间的辅助和元素本身的值决定的。计数排序过程不存在元素之间的比较和交换操作，根据元素本身的值，将每个元素出现的次数记录到辅助空间后，通过对辅助空间的数据计算确定每个元素的最终位置。

> 比较性质排序算法的时间复杂度存在一个理论边界，即$O(\log N)$，N个元素的序列能够形成的所有排列的个数为$N!$，即该序列构成的决策树的叶子节点的个数为$N!$，由叶子节点的个数可以知道决策树的高度为$\log_2(N!)$，即由决策树根节点到叶子节点的比较次数为$\log_2 (N!)$，由斯特灵公式：$n! \approx \sqrt{2\pi n}(\dfrac{n}{e})^n$，转换可得比较性质的算法复杂度理论边界为$O(N\log N)$.

算法的基本流程：

1. 根据待排序集合中的最大元素和最小元素的差值范围，申请额外空间；
2. 遍历待排序集合，将每个元素出现的次数记录在元素值对应的额外空间上；
3. 对额外空间内的数据进行计算得到每个元素正确的位置；
4. 将待排序集合每一个元素移动到计算得到的正确的位置上。

代码见：`count_sort.c`

算法时间复杂度：$O(2N+M)$，其中$M$表示`max_value+1`，即count数组中初始化的项数，$N$表示的是遍历待排序数组的长度。显然我们会发现，如果说$M$的值远远小于$N$时（即大规模数据，但数据的变化范围小），这个算法的复杂度会远远低于$O\log N$的一些排序算法。